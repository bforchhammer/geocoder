<?php

/**
 * Implements hook_field_widget_third_party_settings_form().
 */
function geocoder_geofield_field_widget_third_party_settings_form(\Drupal\Core\Field\WidgetInterface $plugin, \Drupal\Core\Field\FieldDefinitionInterface $field_definition, $form_mode, $form, \Drupal\Core\Form\FormStateInterface $form_state) {
  if (_geocoder_geofield_widget_is_supported($plugin)) {
    // Add a 'my_setting' checkbox to the settings form for 'foo_widget' field
    // widgets.
    $element['enabled'] = array(
      '#type' => 'checkbox',
      '#title' => Drupal::translation()
        ->translate('Use Geocoder to automatically set location from text.'),
      '#default_value' => $plugin->getThirdPartySetting('geocoder_geofield', 'enabled', FALSE),
    );
    /*$source_options = array();
    $element['source'] = array(
        '#type' => 'radio',
        '#options' => ''
    );*/
    return $element;
  }
}

/**
 * Implements hook_field_widget_settings_summary_alter().
 */
function geocoder_geofield_field_widget_settings_summary_alter(&$summary, $context) {
  if (_geocoder_geofield_widget_is_supported($context['widget'])) {
    $enabled = $context['widget']->getThirdPartySetting('geocoder_geofield', 'enabled', FALSE);
    if ($enabled) {
      $summary[] = Drupal::translation()
        ->translate('Geocoding is enabled.');
    }
    else {
      $summary[] = Drupal::translation()
        ->translate('Geocoding is not enabled.');
    }
  }
}

/**
 * Check whether geocoding is supported for a given widget.
 *
 * @param \Drupal\Core\Field\WidgetInterface $widget_obj
 * @return bool|string
 */
function _geocoder_geofield_widget_is_supported(\Drupal\Core\Field\WidgetInterface $widget_obj) {
  try {
    return _geocoder_geofield_find_widget_type($widget_obj);
  } catch (InvalidArgumentException $e) {
    return FALSE;
  }
}

/**
 * Determines the value type for a given widget instance.
 *
 * @see _geocoder_geofield_process_value
 *
 * @param \Drupal\Core\Field\WidgetInterface $widget_obj
 * @return string
 */
function _geocoder_geofield_find_widget_type(\Drupal\Core\Field\WidgetInterface $widget_obj) {
  if ($widget_obj instanceof \Drupal\geofield\Plugin\Field\FieldWidget\GeofieldDefaultWidget) {
    return 'geofield_wkt';
  }
  if ($widget_obj instanceof \Drupal\geofield\Plugin\Field\FieldWidget\GeofieldLatLonWidget) {
    return 'geofield_latlon';
  }
  if ($widget_obj instanceof \Drupal\geofield\Plugin\Field\FieldWidget\GeofieldBoundsWidget) {
    return 'geofield_bounds';
  }
  throw new InvalidArgumentException("Geocoder: unknown widget type.");
}

/**
 * Translates the given geocode into the proper value format for the given
 * widget type.
 *
 * @see _geocoder_geofield_find_widget_type().
 *
 * @param \Geocoder\Result\ResultInterface $geocode
 *   The new geocode.
 * @param $widget_type
 *   The value type, as determined by _geocoder_geofield_find_widget_type().
 * @return array|string
 *   The new form value for the respective geofield widget.
 * @throws Exception
 *   If the widget type is invalid.
 */
function _geocoder_geofield_process_value(\Geocoder\Result\ResultInterface $geocode, $widget_type) {
  switch ($widget_type) {
    case 'geofield_latlon':
      return array(
        'lon' => $geocode->getLongitude(),
        'lat' => $geocode->getLatitude(),
      );

    case 'geofield_wkt':
      return \Drupal::service('geofield.wkt_generator')
        ->WktBuildPoint(array(
          $geocode->getLongitude(),
          $geocode->getLatitude()
        ));

    case 'geofield_bounds':
      $bounds = $geocode->getBounds();
      return array(
        'top' => $bounds['south'],
        'bottom' => $bounds['bottom'],
        'left' => $bounds['west'],
        'right' => $bounds['east'],
      );

    default:
      throw new InvalidArgumentException("Geocoder: unknown widget type.");
  }
}

/**
 * Implements hook_field_widget_form_alter().
 */
function geocoder_geofield_field_widget_form_alter(&$element, \Drupal\Core\Form\FormStateInterface $form_state, $context) {
  if (_geocoder_geofield_widget_is_supported($context['widget']) && $context['widget']->getThirdPartySetting('geocoder_geofield', 'enabled', FALSE)) {
    // Keep track of widget settings in form state, for later use in submit
    // handler.
    $state_key = array(
      'geocoder_geofield',
      $context['items']->getFieldDefinition()->getName()
    );
    if (!($settings = $form_state->get($state_key, FALSE))) {
      $settings = array(
        'widget_type' => _geocoder_geofield_find_widget_type($context['widget']),
        'wrapper_id' => \Drupal\Component\Utility\Html::getUniqueId('geocoder-wrapper'),
        //'settings' => $context['widget']->getThirdPartySetting('geocoder_geofield'),
      );
      $form_state->set($state_key, $settings);
    }

    // Wrap value element into div for ajax replacement.
    $element['value']['#prefix'] = '<div id="' . $settings['wrapper_id'] . '">';
    $element['value']['#suffix'] = '</div>';

    // Attach submit button for updating value from addressfield.
    $element['geocoder_update'] = array(
      '#type' => 'submit',
      '#submit' => array('geocoder_geofield_ajax_submit'),
      '#value' => 'Update coordinates from address',
      '#ajax' => array(
        'callback' => 'geocoder_geofield_ajax_update',
        'wrapper' => $settings['wrapper_id'],
        'method' => 'replaceWith',
        'effect' => 'fade',
      ),
      '#geocoder_widget_type' => $settings['widget_type'],
      // Only validate the address field, as that's the only value we need.
      '#limit_validation_errors' => array(array('field_address')),
    );
  }
}

/**
 * Submit handler for the "geocoder_update" button. Geocodes the current address value, updates the respective
 * geofield input value, and triggers a form rebuild.
 */
function geocoder_geofield_ajax_submit($form, \Drupal\Core\Form\FormStateInterface $form_state) {
  $addresses = $form_state->getValue('field_address');
  $searchstring = geocoder_geofield_format_addressfield($addresses[0]);

  if ($geocode = geocoder_geocode($searchstring)) {
    // Translate geocoded values into value format corresponding to the
    // respective geofield widget.
    $value = _geocoder_geofield_process_value($geocode, $form_state->getTriggeringElement()['#geocoder_widget_type']);

    // Change the user input to reflect the coordinates of the geocoded address.
    // This seems to only work properly if we update the raw user input. If we
    // only change the form "values" instead then the rebuilt form elements
    // do not reflect the new coordinates.
    // @todo Figure out whether this can be solved in a more elegant way.
    $user_input = $form_state->getUserInput();
    $user_input['field_geofield'][0]['value'] = $value;
    $form_state->setUserInput($user_input);

    $form_state->setRebuild(TRUE);
  }
  else {
    drupal_set_message("Address not found.");
  }
}

/**
 * Ajax callback handler. Returns the updated form element, after geocoding.
 */
function geocoder_geofield_ajax_update($form, \Drupal\Core\Form\FormStateInterface $form_state) {
  return $form['field_geofield']['widget'][0]['value'];
}

/**
 * Format and "addressfield" address into a search string for geocoding.
 *
 * @param $address
 *   The addressfield value to be geocoded.
 * @return string
 *   A search string for geocoding.
 */
function geocoder_geofield_format_addressfield($address) {
  // @todo Custom addressfield handler which formats address for geocoding. Should consider how to get best results.
  $address = addressfield_generate($address, array('address'), array('mode' => 'render'));
  $searchstring = drupal_render($address);
  // @todo Move to custom addressfield handler.
  return trim(preg_replace('/\s+/', ' ', $searchstring));
}
